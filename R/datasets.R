#' @title DatasetContainer
#'
#' @rdname SAIL-DatasetContainer
#'
#' @description
#' A container describing the datasets associated with a project
#'
#' @details
#' This helper helper class can be used to:
#' \enumerate{
#'   \item \strong{\emph{Utilities}} -- Dataset-related utility methods, \emph{e.g.} confirming access permissions, collecting the newest refresh tables \emph{etc}
#'   \item \strong{\emph{Parameterisation}} -- General interface to parameterise a set of datasets to be used by a user-defined function and/or method
#'   \item \strong{\emph{Validation}} -- Can be used by user-defined operations to validate the inclusion of projects
#'   \item \strong{\emph{Documentation}} -- An inline documentation of the datasets associated with a project
#' }
#'
#' Several options are available to modify this instance's behaviour that can either be modified globally or on a per call basis:
#' \enumerate{
#'   \item \strong{\emph{SAILR.QUIET}}: Determines whether the \code{DatasetContainer} methods will log debug information
#'   \item \strong{\emph{SAILR.NO.WARN}}: Determines whether warnings will be logged to the console
#'   \item \strong{\emph{SAILR.THROW.ERRORS}}: Specifies whether the current thread should be halted when an error is encountered; you are expected to wrap your \code{SAILR::Connection} calls with an error handler if you deactivate this option
#' }
#'
#' @import R6
#' @import stringr
#' @import vctrs
#' @import rlang
#' @import rstudioapi
#'
#' @export
#'
DatasetContainer <- R6::R6Class(
  'DatasetContainer',
  public = list(
    #' @title DatasetContainer$new
    #'
    #' @description
    #' Initialise a new DatasetContainer
    #'
    #' @example
    #' \preformatted{
    #' # Initialise the container...
    #' datasets = DatasetContainer$new(
    #'   # Some reference table unknown to \code{SAILR.METADATA}; character string references must be a named argument and can't be a reserved name - see \code{DatasetContainer$is.reserved}
    #'   some.table               = 'SAILREFRV.SOME_TABLE',
    #'   # Some project table unknown \code{SAILR.METADATA}; refresh dates should be appended to the name as usual - these can be refreshed using the \code{DatasetContainer$pull.refresh} method
    #'   other.table              = 'SAILXXXV.OTHER_TABLE_20240905',
    #'   # Include some reference table, no schema is needed since this is retrieved from SAILREFRV. Note that the argument name _must_ match \code{DatasetContainer$ref}'s \code{$ref} property if you are using a named argument
    #'   sailref.wimd2019.sm.area = DatasetContainer$ref('sailref.wimd2019.sm.area'),
    #'   # Include some reference table from a project schema; and, as above, the argument name must match the reference name
    #'   adde.deaths              = DatasetContainer$ref('adde.deaths', 'SAILXXXV'),
    #'   # Include a specific refresh of some reference table from a project schema; and, as above, the argument name must match
    #'   abde.births              = DatasetContainer$ref('abde.births', 'SAILXXXV', date='20240905'),
    #;   # Include some reference table from a project schema. Note that the argument name is inferred from the \code{SAILR.METADATA$some.dataset$ref} property
    #'   DatasetContainer$ref('wdsd.pers', 'SAILXXXV', '20240905')
    #' )
    #' }
    #'
    #' @param ... (\code{variadic arguments})\cr
    #'   A set of datasets to be contained by this instance, all arguments should be named unless given as a \code{DatasetContainer$ref}. See the \code{$intliaze} Example section
    #'
    #' @return A new DatasetContainer instance
    #'
    initialize = function (...) {
      private$build.container(...)
    },

    #' @title DatasetContainer$get
    #'
    #' @description
    #' Get the table reference name of the dataset in the shape of \code{[SCHEMA].[TABLE]}
    #'
    #' @param dataset (\code{character})\cr
    #'   The name of the dataset to select
    #'
    #' @return Either (a) a character string representing the table reference if contained by this instance; otherwise (b) an \code{NA} value
    #'
    get = function (dataset) {
      if (!rlang::is_scalar_character(dataset)) {
        return (NA)
      }

      return (private$reference[[dataset]]$reference)
    },

    #' @title DatasetContainer$set
    #'
    #' @description
    #' Sets the key-value pair for the given dataset
    #'
    #' @param dataset (\code{character})\cr
    #'   The name of the dataset to update
    #' @param reference (\code{character|DatasetContainer$ref})\cr
    #'   The table reference in the shape of \code{[SCHEMA].[TABLE]}, or a reference structure generated by the \code{DatasetContainer$ref} static method
    #'
    #' @return The reference to this instance which can be used for chaining, \emph{e.g.} \code{dataset$set('gp.event', 'schema.table')$set('pedw.spell', 'schema.table')}
    #'
    set = function (dataset, reference) {
      private$reference[[dataset]] = private$build.reference(dataset, reference)
      return (invisible(self))
    },

    #' @title DatasetContainer$retrieve
    #'
    #' @description
    #' Retrieves information relating to the specified dataset(s)
    #'
    #' @details
    #' \tabular{lll}{
    #'   Key       \tab Parent     \tab Details                                                                        \cr
    #'   date      \tab Top-level  \tab The selected table date                                                        \cr
    #'   schema    \tab Top-level  \tab The dataset schema                                                             \cr
    #'   relation  \tab Top-level  \tab The dataset type                                                               \cr
    #'   reference \tab Top-level  \tab The table \code{[SCHEMA].[TABLE]} reference                                         \cr
    #'   dataset   \tab Top-level  \tab The dataset object                                                             \cr
    #'   ref       \tab \code{$dataset} \tab The key used to contain this reference                                         \cr
    #'   alt       \tab \code{$dataset} \tab Whether this dataset prepends a prefix to its table name                       \cr
    #'   tag       \tab \code{$dataset} \tab How dates are appended to the table name                                       \cr
    #'   name      \tab \code{$dataset} \tab The name of the dataset                                                        \cr
    #'   origin    \tab \code{$dataset} \tab Where this dataset originated                                                  \cr
    #'   static    \tab \code{$dataset} \tab Whether this dataset is copied to a project, or is hosted in its origin schema \cr
    #' }
    #'
    #' @param dataset (\code{character|vector|list})\cr
    #'   The name of the dataset, or a vector/list of dataset names
    #' @param properties (\code{list|vector})\cr
    #'   An optional flat list or vector of characters specifying which properties to retrieve, see the \code{DatasetContainer$get} example section for more information
    #' @param stop.on.error (\code{logical})\cr
    #'   Whether to return a \code{FALSE} logical when an error is encountered instead of stopping the execution of the parent thread; defaults to \code{option(SAILR.THROW.ERRORS=TRUE)}
    #' @param suppress.warnings (\code{logical})\cr
    #'   Whether to suppress warnings; defaults to \code{option(SAILR.NO.WARN=FALSE)}
    #'
    #' @return Either:
    #'   \enumerate{
    #'     \item If the dataset is present and no properties provided -- a list describing the dataset (or a list of lists if multiple datasets were selected)
    #'     \item If the dataset is present with the given properties -- a key-value pair list containing the information requested (or a list of lists if multiple datasets were selected)
    #'     \item If no dataset by this name is present -- a \code{NA} value
    #'   }
    #'
    retrieve = function (dataset, properties = NA, stop.on.error = getOption('SAILR.THROW.ERRORS', TRUE), suppress.warnings = getOption('SAILR.NO.WARN', FALSE)) {
      caller.env = rlang::caller_env(1)

      if (rlang::is_list(dataset)) {
        dataset = as.vector(unlist(dataset, use.names=FALSE))
      }

      if (rlang::is_list(properties)) {
        properties = as.vector(unlist(properties, use.names=FALSE))
      }

      has.properties = !is.empty(properties)
      if (has.properties && !rlang::is_character(properties)) {
        dt.type = class(properties)[1]
        return (try.abort(
          stringr::str_interp('Failed to retrieve dataset properties, expected either list|vector|NA but got ${dt.type}'),
          call=caller.env, stop.on.error=stop.on.error
        ))
      }

      is.str = rlang::is_scalar_character(dataset)
      is.vec = rlang::is_character(dataset)
      if (!is.str && !is.vec) {
        dt.type = class(dataset)[1]
        try.log(
          'warn', stringr::str_interp(stringr::str_c(
            'Expected dataset parameter as one of character|vector<char>|list<char>',
            'when trying to retrieve a dataset but got ${dt.type}',
            sep=' '
          )),
          caller.env, suppress.warnings=suppress.warnings
        )

        return (NA)
      }

      reference = private$reference
      if (is.str) {
        selected = reference[[dataset]]
        if (is.empty(selected)) {
          return (NA)
        }

        if (has.properties) {
          if (length(properties) > 1) {
            dt.lone = intersect(names(selected), properties)
            dt.ltwo = intersect(names(selected$dataset), setdiff(properties, dt.lone))

            dt.lone = selected[dt.lone]
            dt.ltwo = selected$dataset[dt.ltwo]
            return (append(dt.lone, dt.ltwo))
          }

          if (properties[[1]] %in% names(selected)) {
            return (selected[[properties[[1]]]])
          }

          return (selected$dataset[[properties[[1]]]])
        }

        return (selected)
      }

      results = list()
      for (i in 1:length(dataset)) {
        selected = reference[[dataset[[i]]]]
        if (is.empty(selected)) {
          reference[[dataset[[i]]]] <- NA
          next
        }

        result = list()
        if (has.properties) {
          if (length(properties) > 1) {
            dt.lone = intersect(names(selected), properties)
            dt.ltwo = intersect(names(selected$dataset), setdiff(properties, dt.lone))

            dt.lone = selected[dt.lone]
            dt.ltwo = selected$dataset[dt.ltwo]
            result <- append(dt.lone, dt.ltwo)
          } else {
            if (properties[[1]] %in% names(selected)) {
              result <- append(result, selected[[properties[[1]]]])
            } else {
              result <- append(result, selected$dataset[[properties[[1]]]])
            }
          }
        } else {
          result <- append(result, selected)
        }
        results[[dataset[[i]]]] <- result
      }

      return (results)
    },

    #' @title DatasetContainer$require.datasets
    #'
    #' @description
    #' Tests whether the given datasets have been defined within the DatasetContainer
    #'
    #' @param datasets (\code{character|list|vector})\cr
    #'   A scalar character describing a single dataset, or a list/vector of characters describing which datasets should be refreshed. If the specified dataset element is named, \emph{e.g.} \code{list(abde.births='ABDE_BIRTHS_20240630')}, this method will test both that the \code{abde.births} is present & that it refers to the \code{ABDE_BIRTHS_20240630} table. Note that including a schema, \emph{e.g.} \code{SAIL####V.ABDE_BIRTHS_20240630}, will test both the schema and the dataset name.
    #' @param assert (\code{logical|NA})\cr
    #'   An optional logical that describes whether to throw an error and to stop the execution of the current thread if one or more of the datasets aren't present; defaults to \code{TRUE}
    #'
    #' @return A logical describing whether the datasets are contained by this instance
    #'
    require.datasets = function (datasets, assert = TRUE) {
      assert = coerce.boolean(assert, default=TRUE)
      caller.env = rlang::caller_env(1)

      is.str = rlang::is_scalar_character(datasets)
      if (is.str) {
        datasets = list(datasets)
      }

      if (!is.str && !rlang::is_vector(datasets)) {
        datasets = class(datasets)[1]
        return (try.abort(
          stringr::str_interp('Expected specified datasets as a character string or a list/vector of character strings but got ${datasets}'),
          call=caller.env, stop.on.error=assert
        ))
      }

      des.keys = names(datasets)
      if (!all(sapply(datasets, rlang::is_scalar_character))) {
        datasets = sapply(1:length(datasets), function (i) {
          key = des.keys[[i]]
          val = datasets[[i]]

          if (rlang::is_scalar_character(val)) {
            return (TRUE)
          }

          key = ifelse(!is.string.empty(key), key, paste0('[', toString(i), ']'))
          return (paste(key, ': ', class(val)[1]))
        })

        datasets = do.call(stringr::str_c, append(datasets[datasets != TRUE], list(sep=', ')))
        return (try.abort(
          stringr::str_interp('Expected specified datasets as one of character|list|vector but got { ${datasets} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      reference = private$reference
      if (is.empty(des.keys)) {
        des.keys = rep(FALSE, times=length(datasets))
      } else {
        des.keys = lapply(names(datasets), function (x) (rlang::is_scalar_character(x) && !is.string.empty(x)))
      }

      des.vals = unlist(datasets[des.keys == FALSE], use.names=FALSE)
      des.diff = setdiff(des.vals, names(reference))

      if (length(des.diff) > 0) {
        des.diff = do.call(stringr::str_c, append(des.diff, list(sep=', ')))
        return (try.abort(
          stringr::str_interp('The following datasets are required but were not contained by this DatasetContainer instance: { ${des.diff} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      des.vals = datasets[des.keys == TRUE]
      if (length(des.vals) > 0) {
        ref.keys = names(reference)
        des.diff = mapply(
          function (key, val) {
            if (!(key %in% ref.keys)) {
              return (FALSE)
            }

            return (val == reference[[key]]$reference)
          },
          names(des.vals),
          des.vals
        )

        if (!all(des.diff)) {
          des.diff = des.vals[names(des.diff[des.diff == FALSE])]
          des.diff = mapply(function (k, v) (paste0(k, ': ', v)), names(des.diff), des.diff, USE.NAMES=FALSE)
          des.diff = stringr::str_c(des.diff, sep=', ')
          return (try.abort(
            stringr::str_interp(paste(
              'The following required datasets were mismatched, they may have been incorrectly defined',
              'or not contained by this DatasetContainer instance: { ${des.diff} }',
              sep=' '
            )),
            call=caller.env, stop.on.error=assert
          ))
        }
      }

      if (assert) {
        return (invisible(TRUE))
      }

      return (TRUE)
    },

    #' @title DatasetContainer$require.like
    #'
    #' @description
    #' Tests whether a dataset's reference refers to a specific relation type
    #'
    #' @details
    #' \tabular{lll}{
    #'   Type         \tab Schema regex            \tab Details                                                         \cr
    #'   \code{BASE}       \tab \code{^BASE}            \tab A base schema from which datasets are cloned                    \cr
    #'   \code{REFERENCE}  \tab \code{^SAIL[A-Z][\\w]+$} \tab A dataset reference schema containing the datasets              \cr
    #'   \code{SESSION}    \tab \code{^SESSION$}        \tab A global temporary table for this session                       \cr
    #'   \code{PROJECT}    \tab \code{^SAIL\\d+V$}       \tab A project table cloned from \code{BASE}, \code{REFERENCE} or \code{ENCRYPTION} \cr
    #'   \code{WORKSPACE}  \tab \code{^SAILW\\d+V$}      \tab A project workspace containing user-defined tables              \cr
    #'   \code{ENCRYPTION} \tab \code{^SAILX\\d+V$}      \tab A project-level encryption table                                \cr
    #' }
    #'
    #' @param datasets (\code{character|list|vector})\cr
    #'   The name of the dataset, or a list/vector of characters, specifying dataset(s) to test
    #' @param relation (\code{character})\cr
    #'   A scalar character a relation comparator(s) which can be one of: \code{BASE}, \code{REFERENCE}, \code{SESSION}, \code{PROJECT}, \code{WORKSPACE}, \code{ENCRYPTION} or \code{UNKNOWN} - see \code{SAILR.DEF$DREF.RELATION} for more details
    #' @param assert (\code{logical|NA})\cr
    #'   An optional logical that describes whether to throw an error and to stop the execution of the current thread if one or more of the datasets aren't present; defaults to \code{TRUE}
    #'
    #' @return A logical describing whether the dataset is
    #'
    require.like = function (datasets, relation, assert = TRUE) {
      assert = coerce.boolean(assert, default=TRUE)
      reference = private$reference
      caller.env = rlang::caller_env(1)

      if (!rlang::is_scalar_character(relation)) {
        relation = class(relation)[1]
        return (try.abort(
          stringr::str_interp('Expected specified relation as a character string but got ${relation}'),
          call=caller.env, stop.on.error=assert
        ))
      }

      relation = toupper(relation)
      available = names(SAILR.DEF$DREF.RELATION)
      if (!(relation %in% available)) {
        available = do.call(stringr::str_c, append(available, list(sep=', ')))
        return (try.abort(
          stringr::str_interp('Relation of type "${relation}" specified but expected one of: { ${available} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      if (rlang::is_scalar_character(datasets)) {
        datasets = list(datasets)
      }

      if (!rlang::is_vector(datasets)) {
        datasets = class(datasets)[1]
        return (try.abort(
          stringr::str_interp('Expected specified datasets as a character string or a list/vector of character strings but got ${datasets}'),
          call=caller.env, stop.on.error=assert
        ))
      }

      if (!all(sapply(datasets, rlang::is_scalar_character))) {
        dt.keys = names(datasets)
        datasets = sapply(1:length(datasets), function (i) {
          key = dt.keys[[i]]
          val = datasets[[i]]

          if (rlang::is_scalar_character(val)) {
            return (TRUE)
          }

          key = ifelse(!is.string.empty(key), key, paste0('[', toString(i), ']'))
          return (paste(key, ': ', class(val)[1]))
        })

        datasets = do.call(stringr::str_c, append(datasets[datasets != TRUE], list(sep=', ')))
        return (try.abort(
          stringr::str_interp('Expected specified datasets as one of character|list|vector but got { ${datasets} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      all.present = self$require.datasets(datasets, assert=FALSE)
      if (!all.present) {
        reason = attr(all.present, 'reason')
        reason = ifelse(rlang::is_scalar_character(reason), reason, 'Unknown error occurred when confirming dataset existence')
        return (try.abort(reason, call=caller.env, stop.on.error=assert))
      }

      items = reference[sapply(names(reference), function (x) (x %in% datasets))]
      conds = sapply(items, function (x) (x$relation == relation))
      if (any(conds == FALSE)) {
        items = mapply(function (k, v) (paste0(k, ': ', v$relation)), names(items[conds == FALSE]), items[conds == FALSE], USE.NAMES=FALSE)
        items = stringr::str_c(items, sep=', ')
        return (try.abort(
          stringr::str_interp('Some datasets did not match the required relation of "${relation}", see the following: { ${items} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      if (assert) {
        return (invisible(TRUE))
      }

      return (TRUE)
    },

    #' @title DatasetContainer$require.access
    #'
    #' @description
    #' Tests whether the client has the privileges to interface with the datasets defined within this container.
    #'
    #' Note that '_privileges_' could describe one of the following privileges: \code{SELECT}, \code{UPDATE}, \code{INSERT} \emph{etc}. Please see IBM's documentation on
    #' user privileges \href{https://www.ibm.com/docs/en/bpm/8.5.6?topic=privileges-db2-database}{here} for more information, or see \code{SAILR.DEF$PRIVILEGES}
    #'
    #' @param db (\code{<SAILR>})\cr
    #'   An active, valid \code{<SAILR>} database connection
    #' @param privileges (\code{list})\cr
    #'   A named list in which the key describes the dataset, and where the value describes which privileges are required, \emph{e.g.} \code{list(gp.events=c('INSERT', 'SELECT'), pedw.spell='ALL')}. Note that \code{ALL} expands to all privileges described by \code{SAILR.DEF$PRIVILEGES}
    #' @param assert (\code{logical|NA})\cr
    #'   An optional logical that describes whether to throw an error and to stop the execution of the current thread if one or more of the datasets aren't present; defaults to \code{TRUE}
    #'
    #' @return A logical reflecting whether the client has the privileges to interface with the datasets
    #'
    require.access = function (db, privileges, assert = TRUE) {
      assert = coerce.boolean(assert, default=TRUE)
      reference = private$reference
      caller.env = rlang::caller_env(1)

      if (!Connection$is.valid(db)) {
        return (try.abort(
          'Unable to validate dataset access with an invalid or inactive database connection - please specify a valid db parameter',
          call=caller.env, stop.on.error=assert
        ))
      }

      username = db$username
      if (username == '[UID]') {
        return (try.abort('Failed to derive username from connection string, your SAILR connection might be invalid', call=caller.env, stop.on.error=assert))
      }

      if (!is.named.list(privileges, accept.named.vecs=TRUE)) {
        privileges = class(privileges)[1]
        if (privileges == 'list') {
          privileges = 'unnamed list'
        }

        return (try.abort(
          stringr::str_interp('Expected specified privileges parameter as a named list but got ${privileges}'),
          call=caller.env, stop.on.error=assert
        ))
      }

      if (!all(sapply(unlist(privileges, use.names=FALSE), function (x) (rlang::is_scalar_character(x))))) {
        return (try.abort('Not every element in the privileges parameter resolved to a scalar character', call=caller.env, stop.on.error=assert))
      }

      datasets = names(privileges)
      all.present = self$require.datasets(datasets, assert=FALSE)
      if (!all.present) {
        reason = attr(all.present, 'reason')
        reason = ifelse(rlang::is_scalar_character(reason), reason, 'Unknown error occurred when confirming dataset existence')
        return (try.abort(reason, call=caller.env, stop.on.error=assert))
      }

      test.data = mapply(
        function (key, value) {
          ref = reference[[key]]
          if (rlang::is_scalar_character(value) && toupper(value) == 'ALL') {
            value = SAILR.DEF$PRIVILEGES
          }

          count = 0
          if (rlang::is_vector(value)) {
            count = length(value)
            value = do.call(stringr::str_c, append(as.list(unlist(value, use.names=FALSE)), list(sep=',')))
          } else {
            count = 1
          }

          tname = interpolate.reference(ref, as.table.name=TRUE)
          return (paste0('(\'', key, '\', \'', ref$schema, '\', \'', tname, '\', \'', toupper(value), '\', ', count, ')'))
        },
        names(privileges),
        privileges
      )

      test.data = do.call(paste, append(test.data, list(sep=',\n')))
      test.results = db$run(stringr::str_interp("
      SELECT
          DKEY,
          DCOUNT,
          OBJECTSCHEMA,
          OBJECTNAME,
          COUNT(DISTINCT PRIVILEGE) AS PRIVILEGE
        FROM (
          SELECT DISTINCT
              P.AUTHID,
              P.OBJECTSCHEMA,
              P.OBJECTNAME,
              T.DKEY,
              T.DCOUNT,
              P.PRIVILEGE
            FROM SYSIBMADM.PRIVILEGES AS P,
                 SYSIBMADM.AUTHORIZATIONIDS AS A,
                 TABLE (SYSPROC.AUTH_LIST_GROUPS_FOR_AUTHID(UPPER('${username}'))) AS U
            JOIN (
              VALUES
                ${test.data}
            ) AS T(DKEY, DSCHEMA, DTABLE, DPRIVILEGES, DCOUNT)
              ON P.OBJECTSCHEMA = T.DSCHEMA AND P.OBJECTNAME = T.DTABLE
           WHERE LOCATE(TRIM(P.PRIVILEGE), T.DPRIVILEGES) > 0
             AND (
                  (A.AUTHIDTYPE = 'G' AND A.AUTHID = P.AUTHID AND (U.GROUP = A.AUTHID OR A.AUTHID = 'PUBLIC'))
               OR (P.AUTHID = U.GROUP)
               OR (P.AUTHIDTYPE = 'U' AND P.AUTHID = UPPER('${username}'))
             )
        )
       GROUP BY DKEY, DCOUNT, OBJECTSCHEMA, OBJECTNAME;
      "), stop.on.error = FALSE, suppress.logs = TRUE, suppress.warnings = TRUE)

      if (!is.data.frame(test.results)) {
        reason = attr(test.results, 'reason')
        if (!rlang::is_scalar_character(reason)) {
          reason = 'Unknown error occurred when querying privileges'
        }

        return (try.abort(stringr::str_interp('Failed to validate privileges with error: ${reason}'), call=caller.env, stop.on.error=assert))
      }

      test.absent = setdiff(datasets, test.results$DKEY)
      if (length(test.absent) > 0) {
        test.absent = do.call(stringr::str_c, append(test.absent, list(sep=', ')))
        return (try.abort(
          stringr::str_interp('Failed to locate any of the required privileges for the following dataset(s): { ${test.absent} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      test.failed = test.results[which(test.results$DCOUNT < test.results$PRIVILEGE),]
      if (nrow(test.failed) > 0) {
        test.failed = apply(test.failed, 1, function (x) {
          return (paste0(
            x['DKEY'], ', table: "', x['OBJECTSCHEMA'], '.', x['OBJECTNAME'],
            '", expected ', x['DCOUNT'], ' privileges but found only ', x['PRIVILEGE']
          ))
        })

        test.failed = do.call(stringr::str_c, append(test.failed, list(sep='\n')))
        return (try.abort(stringr::str_interp('Failed to validate privileges with error: ${test.failed}'), call=caller.env, stop.on.error=assert))
      }

      if (assert) {
        return (invisible(TRUE))
      }

      return (TRUE)
    },

    #' @title DatasetContainer$require.shape
    #'
    #' @description
    #' Tests whether the given dataset(s) meet the selected criteria by ensuring each of its columns and their datatypes
    #' match those specified
    #'
    #' @param db (\code{<SAILR>})\cr
    #'   An active, valid \code{<SAILR>} database connection
    #' @param criteria (\code{list})\cr
    #'   A list of column criteria for one or more dataset(s), \emph{e.g.} \code{list(gp.event=list(ALF_PE='BIGINTEGER))}, in which each key of each inner list describes of the column name(s) and the value(s) specify the required column's type. Do note that types are fuzzy matched to exclude matching on size unless explicitly specified, \emph{e.g.} \code{list(some.table=list(SOME_TEXT_COL='VARCHAR'))} _v.s._ \code{list(some.table=list(SOME_TEXT_COL='VARCHAR(200)'))}. Please do note that names, columns and types are case sensitive.
    #' @param assert (\code{logical|NA})\cr
    #'   An optional logical that describes whether to throw an error and to stop the execution of the current thread if one or more of the datasets aren't present; defaults to \code{TRUE}
    #'
    #' @return A logical reflecting whether the criteria has been met
    #'
    require.shape = function (db, criteria, assert = TRUE) {
      assert = coerce.boolean(assert, default=TRUE)
      reference = private$reference
      caller.env = rlang::caller_env(1)

      if (!Connection$is.valid(db)) {
        return (try.abort(
          'Unable to test shape of datasets with an invalid or inactive database - please specify a valid db parameter',
          call=caller.env, stop.on.error=assert
        ))
      }

      if (!is.named.list(criteria, accept.named.vecs=TRUE)) {
        criteria = class(criteria)[1]
        if (criteria == 'list') {
          criteria = 'unnamed list'
        }

        return (try.abort(
          stringr::str_interp('Expected specified criteria parameter as a named list but got ${criteria}'),
          call=caller.env, stop.on.error=assert
        ))
      }

      datasets = names(criteria)
      all.present = self$require.datasets(datasets, assert=FALSE)
      if (!all.present) {
        reason = attr(all.present, 'reason')
        reason = ifelse(rlang::is_scalar_character(reason), reason, 'Unknown error occurred when confirming dataset existence')
        return (try.abort(reason, call=caller.env, stop.on.error=assert))
      }

      test.data = list()
      for (i in 1:length(criteria)) {
        key = datasets[[i]]
        if (is.string.empty(key)) {
          return (try.abort(
            stringr::str_interp('Failed to generate criteria query, expected named list but got empty name at index ${i}'),
            call=caller.env, stop.on.error=assert
          ))
        }

        req = criteria[[i]]
        if (!is.named.list(req)) {
          req = class(req)[1]
          return (try.abort(
            stringr::str_interp('Expected named list at Criteria<index: ${i}, key: ${key}> but got ${req}'),
            call=caller.env, stop.on.error=assert
          ))
        }

        ref = reference[[key]]
        test.data <- append(test.data, paste0('(\'', key, '\', \'', ref$reference, '\')'))
      }

      test.data = do.call(paste, append(test.data, list(sep=',\n')))
      test.results = db$run(stringr::str_interp("
      SELECT
          SEL.TABKEY,
          SEL.TABREF,
          COL.COLNAME,
          COL.TYPENAME,
          CASE
            WHEN COL.TYPENAME = 'VARCHAR'   THEN   'VARCHAR(' || COL.LENGTH || ')'
            WHEN COL.TYPENAME = 'CHARACTER' THEN 'CHARACTER(' || COL.LENGTH || ')'
            WHEN COL.TYPENAME = 'DECIMAL'   THEN   'DECIMAL(' || COL.LENGTH || ',' || COL.SCALE || ')'
            ELSE TYPENAME
          END AS COLTYPE
        FROM SYSCAT.COLUMNS AS COL
        JOIN (
          VALUES
            ${test.data}
        ) AS SEL(TABKEY, TABREF)
          ON COL.TABSCHEMA || '.' || COL.TABNAME = SEL.TABREF
      "), stop.on.error = FALSE, suppress.logs = TRUE, suppress.warnings = TRUE)

      if (!is.data.frame(test.results)) {
        reason = attr(test.results, 'reason')
        if (!rlang::is_scalar_character(reason)) {
          reason = 'Unknown error occurred when querying privileges'
        }

        return (try.abort(stringr::str_interp('Failed to validate criteria of table with error: ${reason}'), call=caller.env, stop.on.error=assert))
      }

      test.absent = setdiff(datasets, test.results$TABKEY)
      if (length(test.absent) > 0) {
        test.absent = do.call(stringr::str_c, append(test.absent, list(sep=', ')))
        return (try.abort(
          stringr::str_interp('Failed to locate any of the required columns for the following dataset(s): { ${test.absent} }'),
          call=caller.env, stop.on.error=assert
        ))
      }

      for (i in 1:length(criteria)) {
        key = datasets[[i]]
        col.types = criteria[[i]]
        col.names = names(col.types)

        test.table = test.results[test.results$TABKEY == key,]
        test.columns = mapply(
          function (col.name, col.type) {
            col.datatypes = as.list(test.table[test.table$COLNAME == col.name, c('TYPENAME', 'COLTYPE')])
            return (col.type %in% col.datatypes)
          },
          col.names,
          col.types
        )

        if (any(test.columns == FALSE)) {
          test.columns = test.columns[test.columns == FALSE]
          test.columns = do.call(stringr::str_c, append(names(test.columns), list(sep=', ')))
          return (try.abort(
            stringr::str_interp('Failed to validate the shape of Dataset<name: ${key}> for the following required columns: ${test.columns}'),
            call=caller.env, stop.on.error=assert
          ))
        }
      }

      if (assert) {
        return (invisible(TRUE))
      }

      return (TRUE)
    },

    #' @title DatasetContainer`[`
    #'
    #' @description
    #' Subscript operator overload to retrieve one or more table references
    #' derived from the indexed dataset(s)
    #'
    #' @example
    #' \preformatted{
    #' some.container[c('gp.event', 'other.table')]
    #' }
    #'
    #' @param datasets (\code{character|vector})\cr
    #'   The datasets to index
    #'
    #' @return The dataset references, if contained by this instance
    #'
    `[` = function (datasets) {
      return (private$reference[datasets])
    },

    #' @title DatasetContainer$`[[`
    #'
    #' @description
    #' Subscript operator overload to retrieve one or more table references
    #' derived from the indexed dataset(s)
    #'
    #' @example
    #' \preformatted{
    #' some.container[['gp.event']]
    #' }
    #'
    #' @param dataset (\code{character})\cr
    #'   The dataset to index
    #'
    #' @return A dataset reference, if contained by this instance
    #'
    `[[` = function (dataset) {
      return (private$reference[[dataset]])
    },

    #' @title DatasetContainer$length
    #'
    #' @description
    #' Compute the length of the datasets contained by this instance
    #'
    #' @param ... (\code{variadic arguments})\cr
    #'   Optional varargs from the \code{length} call
    #'
    #' @return An integer describing the number of datasets referenced by this instance
    #'
    length = function (...) {
      ref = private$reference
      if (rlang::is_list(ref)) {
        return (length(ref))
      }

      return (0)
    }
  ),

  private = list(
    #' @field reference (\code{list})\cr
    #'   A private reference to the datasets contained by this instance
    #'
    reference = NA,

    #' @title DatasetContainer$build.container
    #'
    #' @description
    #' An internal, private constructor
    #'
    #' @param ... (\code{variadic arguments})\cr
    #'   Constructor arguments
    #'
    build.container = function (...) {
      caller.env = rlang::caller_env(2)

      args = list(...)
      keys = names(args)

      issues = list()
      reference = list()
      for (i in 1:length(args)) {
        arg = args[[i]]
        key = keys[i]

        ref = try(suppressWarnings(private$build.reference(key, arg)), silent=TRUE)
        if (inherits(ref, 'try-error')) {
          index = length(issues) + 1
          issues <- append(issues, stringr::str_interp(paste('  ${index}. ', toString(ref))))
          next
        }

        key = ifelse(is.string.empty(key), ref$dataset$ref, key)
        if (length(reference) > 0 && key %in% names(reference)) {
          index = length(issues) + 1
          issues <- append(issues, stringr::str_interp(paste(
            '  ${index}. Malformed argument of Argument<pos: ${i}, key: ${key}, value: ${arg$dataset$ref}>,',
            'redefinition of ${key} - it\'s already referenced elsewhere in the arguments',
            sep=' '
          )))
        }

        reference[[key]] <- ref
      }

      if (length(issues) > 0) {
        issues = do.call(paste, append(issues, list(sep='\n')))
        rlang::abort(stringr::str_interp('Failed to construct `DatasetContainer` instance with error(s):\n\n${issues}'))
      }

      private$reference = reference
    },

    #' @title DatasetContainer$build.reference
    #'
    #' @description
    #' Private method to construct a dataset reference
    #'
    #' @param key (\code{character})\cr
    #'   A scalar character string specifying the dataset key
    #' @param arg (\code{character|DatasetReference})\cr
    #'   Either (a) a scalar character describing a table reference; or (b) a \code{DatasetReference} instance
    #'
    #' @return A \code{DatasetItem} or \code{DatasetReference} instance, with respect to the given \code{arg} type
    #'
    build.reference = function (key, arg) {
      if (inherits(arg, SAILR.DEF$DREF.CLASS)) {
        if (is.string.empty(key)) {
          key = arg$dataset$ref
        }

        if (key != arg$dataset$ref) {
          rlang::abort(stringr::str_interp(paste(
            'Malformed argument of Argument<pos: ${i}, key: ${key}, value: ${arg$dataset$ref}>,',
            'expected key to match the dataset reference of ${arg$dataset$ref} but got ${key}',
            sep=' '
          )))
        }

        return (arg)
      } else if (rlang::is_scalar_character(arg)) {
        if (is.string.empty(key)) {
          rlang::abort(stringr::str_interp(paste(
            'Malformed argument of Argument<pos: ${i}, value: ${arg}>,',
            'expected named argument key for this argument type, e.g. `key=${arg}`',
            sep=' '
          )))
        }

        dref.components = parse.dataset.components(arg)
        if (!rlang::is_list(dref.components)) {
          reason = attr(dref.components, 'reason')
          if (!rlang::is_scalar_character(reason)) {
            reason = 'Unknown parsing error occurred'
          }

          rlang::abort(stringr::str_interp(paste(
            'Malformed argument of Argument<pos: ${i}, key: ${key}, value: ${arg}>,',
            'failed to parse table reference with error: ${reason}',
            sep=' '
          )))
        }

        return (structure(
          list(
            date=dref.components$date,
            schema=dref.components$schema,
            reference=arg,
            dataset=list(
              ref=key,
              alt=FALSE,
              tag=dref.components$tag,
              name=dref.components$name,
              origin=dref.components$schema,
              static=dref.components$static
            ),
            relation=dref.components$relation
          ),
          class=SAILR.DEF$DUDF.CLASS
        ))
      }
    }
  ),

  active = list(
    #' @field datasets (\code{character|NA})\cr
    #'   A read-only field describing the datasets contained by this instance
    #'
    datasets = function () {
      return (private$reference)
    }
  )
)


#' @title DatasetContainer$is
#'
#' @description
#' Static method to test whether the given value is an instance of a DatasetContainer
#'
#' @param obj (\code{any})\cr
#'   Some value to test
#' @param scalar (\code{logical|NA})\cr
#'   An optional logical that determines whether the given value must be a scalar to pass the test; defaults to \code{TRUE}
#'
#' @return A logical reflecting whether the value is a DatasetContainer instance
#'
DatasetContainer$is <- function (obj, scalar = TRUE) {
  if (!rlang::is_vector(obj)) {
    return (inherits(obj, 'DatasetContainer'))
  }

  scalar = coerce.boolean(scalar, default=TRUE)
  if (!scalar) {
    return (all(sapply(obj, function (x) (inherits(obj, 'DatasetContainer')))))
  }

  return (FALSE)
}


#' @title DatasetContainer$ref
#'
#' @description
#' Static method to reference a table by its reserved name, can be used in the \code{datasets}
#' parameter to expand to a table reference \emph{e.g.} \code{DatasetContainer$ref('gp.event')} would resolve to \code{WLGP_GP_EVENT_CLEANSED} \emph{etc}
#'
#' @param ... (\code{variadic arguments})\cr
#'   Takes the following parameters, either unnamed in the order of the items below, or by name:
#'   \enumerate{
#'     \item dataset -- mandatory character string referencing a dataset name as defined by \code{SAILR.METADATA}
#'     \item schema -- an optional character string describing the schema of the given dataset - required for non-static datasets, see \code{SAILR.METADATA} reference
#'     \item date -- an optional date string, or \code{as.Date()} object, referencing the refresh date of this dataset - only required for datasets tagged with a \code{_${date}}. Note that the \code{date} argument, if defined as a character string, should be formatted as \code{%Y-%m-%d} unless a \code{date.fmt} argument is specified.
#'     \item date.fmt -- an optional date format option defined as a character string; defaults to \code{UTC} timezone unless the \code{date.tz} argument is specified. If not specified, this method will attempt a variety of datetime formats as described by \code{SAILR.DEF$DATETIME.FORMATS}
#'     \item date.tz -- an optional timezone name; defaults to \code{option(SAILR.TIMEZONE = SAILR.DEF$TIMEZONE)}
#'   }
#'
#' @return An anonymous structure with attributes referencing the selected dataset
#'
DatasetContainer$ref <- function (...) {
  caller.env = rlang::caller_env(1)
  params = parse.params(c('dataset', 'schema', 'date', 'date.fmt', 'date.tz'), ...)

  if (!rlang::is_scalar_character(params$dataset)) {
    typename = class(params$dataset)[1]
    return (try.abort(
      stringr::str_interp('Failed to define dataset reference, malformed dataset parameter - expected scalar character but got ${typename}'),
      call=caller.env
    ))
  }

  if (!(params$dataset %in% names(SAILR.METADATA))) {
    return (try.abort(
      stringr::str_interp('No known dataset object by the specified dataset name of "${params$dataset}"'),
      call=caller.env
    ))
  }

  dataset = SAILR.METADATA[[params$dataset]]
  is.static.dt = coerce.boolean(dataset$static)
  if (!is.static.dt && is.string.empty(params$schema)) {
    typename = class(params$schema)[1]
    return (try.abort(
      stringr::str_interp('Expected scalar character for schema parameter for this type of dataset but got ${typename} - please see `SAILR.METADATA`'),
      call=caller.env
    ))
  } else if (is.static.dt && is.string.empty(params$schema)) {
    params$schema = dataset$origin
  }

  if (!rlang::is_scalar_character(dataset$tag)) {
    params$date = NULL
  } else if (rlang::is_scalar_character(params$date)) {
    tz = ifelse(rlang::is_scalar_character(params$date.tz), params$date.tz, NA)

    if (!is.empty(params$fmt)) {
      date = try(suppressWarnings(get.datetime.from.string(params$date, fmt=params$fmt, tz=tz)), silent=TRUE)
    } else {
      date = try(suppressWarnings(get.datetime.from.string(params$date, tz=tz)), silent=TRUE)
    }

    if (!inherits(date, 'Date') && !inherits(date, 'POSIXct')) {
      return (try.abort(
        stringr::str_interp(paste(
          'Failed to parse date from specified date string;',
          'expected valid, non-empty datetime for refresh datasets but got ${params$date}',
          '- see formatting options in `SAILR.DEF`',
          sep=' '
        )),
        call=caller.env
      ))
    } else {
      params$date = date
    }
  } else if (!inherits(params$date, 'Date') && !inherits(params$date, 'POSIXct')) {
    typename = class(params$date)[1]
    return (try.abort(
      stringr::str_interp('Malformed mandatory date parameter for this dataset type, got ${typename} - please see `SAILR.METADATA`'),
      call=caller.env
    ))
  }

  relation = get.dataset.relation(params$schema)
  result = list(dataset=dataset, schema=params$schema, date=params$date, relation=relation)
  result[['reference']] = interpolate.reference(result)

  return (structure(result, class=SAILR.DEF$DREF.CLASS))
}


#' @title DatasetContainer$is.reserved
#'
#' @description
#' A helper static method to test whether the given value is a reserved dataset name, \emph{i.e.} one that is defined by the
#' internal dataset metadata. This method can be used to validate your keywords to ensure they don't conflict with the expectations
#' of another package
#'
#' @param name (\code{character|vector|list})\cr
#'   Some scalar character name to test, or a vector/list of characters to test
#'
#' @return A logical reflecting whether the value(s) is/are a reserved dataset name; note that non-string values are falsy and any non-string arguments will result in a \code{FALSE} return value
#'
DatasetContainer$is.reserved <- function (name) {
  if (rlang::is_vector(name)) {
    name = unlist(name, use.names=FALSE)
    rnames = names(SAILR.METADATA)
    return (sapply(name, function (x) {
      if (!rlang::is_scalar_character(x)) {
        return (FALSE)
      }

      return (x %in% rnames)
    }))
  }

  if (!rlang::is_scalar_character(name)) {
    return (FALSE)
  }

  return (name %in% names(SAILR.METADATA))
}


#' @title length.DatasetContainer
#'
#' @description
#' An override for the \code{length()} function that dispatches the call to the instance's \code{DatasetContainer$length} method
#'
#' @param obj (\code{<DatasetContainer>})\cr
#'   Some \code{DatasetContainer} instance
#' @param ... (\code{variadic arguments})\cr
#'   Optional varargs for the \code{length} function
#'
#' @return A string representation of the \code{DatasetContainer} instance
#'
#' @rdname SAIL-DatasetContainer
#'
#' @export
#'
length.DatasetContainer <- function (obj, ...) {
  return (obj$length(...))
}


#' @title
#' Overloaded subscript operator
#'
#' @description
#' Subscript operator overload to retrieve one or more table references
#' derived from the indexed dataset(s)
#'
#' @param datasets (\code{character|vector})\cr
#'   The datasets to index
#'
#' @return The dataset references, if contained by this instance
#'
#' @rdname SAIL-DatasetContainer
#'
#' @export
#'
`[.DatasetContainer` <- function(obj, ...) {
  return (obj$`[`(...))
}


#' @title
#' Overloaded index operator
#'
#' @description
#' Subscript operator overload to retrieve one or more table references
#' derived from the indexed dataset(s)
#'
#' @param dataset (\code{character})\cr
#'   The dataset to index
#'
#' @return A dataset reference, if contained by this instance
#'
#' @rdname SAIL-DatasetContainer
#'
#' @export
#'
`[[.DatasetContainer` <- function(obj, ...) {
  return (obj$`[[`(...))
}
